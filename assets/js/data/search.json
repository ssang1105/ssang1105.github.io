[ { "title": "2357. Make Array Zero by Subtracting Equal Amounts", "url": "/posts/LeetCode-2357-Make-Array-Zero-By-Subtracting-Equals-Amount/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-12-14 22:00:00 +0900", "snippet": "2357. Make Array Zero by Subtracting Equal AmountsProblem &amp;amp; ExampleQuestions before reading example나의 풀이time complexity : O(n^2)space complexity : O(1)다른 풀이 (SIMPLE, EASY-UNDERSTANDING)class Solution { public int minimumOperations(int[] nums) { HashSet&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); for(int a : nums) { if(a &amp;gt; 0) set.add(a); } return set.size(); }}Spent time 5mReview 문제 그대로 brute force 하게 풀었다. 하지만.. 문제를 깊이 이해하고 나면, Set 으로 한방에 풀 수 있다는 걸 알 수 있다. (물론 나도 discussion 을 보고 알았다) 낮은 수부터 빼고, 중복숫자 빼고.." }, { "title": "323. Number of Connected Components in an Undirected Graph", "url": "/posts/LeetCode-323-Number-Of-Connected-Components-In-An-Undirected-Graph/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-12-14 21:00:00 +0900", "snippet": "323. Number of Connected Components in an Undirected GraphProblem &amp;amp; ExampleQuestions before reading example나의 풀이time complexity : O(E+V) (E=Number of edges, V=Number of vertices)space complexity : O(E+V) (E=Number of edges, V=Number of vertices)Spent time 30m 이상Review 어려웠던.. 백트래킹 문제였다. Map&amp;lt;Integer,List 에 저장하는것까진 잘 도출했지만, 그 이후는 어려웠다. 처음에 edgeMap 을 모두 초기화 시키는것도 떠올리지 못해 Solution 을 보았다. 한번 더 풀어보면 좋을 문제다." }, { "title": "LeetCode 1165. Single-Row Keyboard", "url": "/posts/LeetCode-1165-Single-Row-Keyboard/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-12-02 20:00:00 +0900", "snippet": "1165. Single-Row KeyboardProblem &amp;amp; ExampleQuestions before reading example나의 풀이time complexity : O(n)space complexity : O(1)Spent time 8mReview String 의 indexOf 만 알면 쉽게 풀 수 있는 문제" }, { "title": "LeetCode 1198. Find Smallest Common Element in All Rows", "url": "/posts/LeetCode-1198-Find-Smallest-Common-Element-In-All-Rows/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-11-30 23:20:00 +0900", "snippet": "1198. Find Smallest Common Element in All RowsProblem &amp;amp; ExampleQuestions before reading example나의 풀이time complexity : O(m * n)space complexity : O(n)Count Elements 풀이time complexity : O(m * n)space complexity : O(1)Binary Search 풀이time complexity : O(m * n * logn)space complexity : O(1)Spent time 15mReview hash map 을 사용하여 쉽게 풀었다. 같은 아이디어지만, HashMap 안쓰고 Elements 를 count 한 풀이가 더 효율적이고 좋군.." }, { "title": "LeetCode 832. Flipping An Image", "url": "/posts/LeetCode-832-Flipping-An-Image/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-11-21 23:30:00 +0900", "snippet": "832. Flipping An ImageProblem &amp;amp; ExampleQuestions before reading example나의 풀이Spent time 10mReview 단순하게 문제에 나와있는 아이디어 그대로 풀면 풀리겠지..? 싶었는데 다행히 잘 풀렸다." }, { "title": "LeetCode 797. All Paths From Source to Target", "url": "/posts/LeetCode-797-All-Paths-From-Source-To-Target/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-11-21 23:30:00 +0900", "snippet": "797. All Paths From Source to TargetProblem &amp;amp; ExampleQuestions before reading example나의 풀이Spent time 30mReview dfs, backtracking 와 친해지는중.. index 를 알맞게 잘 활용하는 것(target 과 length - 1, 2차원 array 등) 은 항상 어렵다. 처음에 0 을 넣어주는 아이디어도 discussion 을 통해서 알 수 있었다." }, { "title": "LeetCode 21. Merge Two Sorted Lists", "url": "/posts/LeetCode-21-MergeTwoSortedLists/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-11-15 00:00:00 +0900", "snippet": "21. Merge Two Sorted ListsProblem &amp;amp; ExampleQuestions before reading example나의 풀이Spent time 30mReview 진짜 쉽고 간단한 문제였는데.. handler 라는 아이디어를 내지 못해서 오래걸렸다." }, { "title": "LeetCode 9. Palindrome Number", "url": "/posts/LeetCode-9-PalindromeNumber/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-11-14 00:00:00 +0900", "snippet": "9. Palindrome NumberProblem &amp;amp; ExampleQuestions before reading example나의 풀이Spent time 5mReview 예전에 분명히 풀어보았던 팰린드롬의 수 문제 함정이 있을까 조마조마하며 풀었는데 다행히 한번에 잘 풀렸다." }, { "title": "LeetCode 48. Group Anagrams", "url": "/posts/LeetCode-49-Group-Anagrams/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-11-13 00:00:00 +0900", "snippet": "48. Group AnagramsProblemGiven an array of strings strs, group the anagrams together. You can return the answer in any order.An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.Questions before reading exampleExampleInput: strs = [&quot;eat&quot;,&quot;tea&quot;,&quot;tan&quot;,&quot;ate&quot;,&quot;nat&quot;,&quot;bat&quot;]Output: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]Input: strs = [&quot;&quot;]Output: [[&quot;&quot;]]Input: strs = [&quot;a&quot;]Output: [[&quot;a&quot;]]Solution 나의 풀이 class Solution { public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; groupAnagrams(String[] strs) { Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; inspectionMap = new HashMap&amp;lt;&amp;gt;(); for (String input : strs) { char[] inputChars = input.toCharArray(); Arrays.sort(inputChars); String key = String.valueOf(inputChars); if (inspectionMap.get(key) == null) { List&amp;lt;String&amp;gt; arrayList = new ArrayList&amp;lt;&amp;gt;(); arrayList.add(input); inspectionMap.put(key, arrayList); } else { List&amp;lt;String&amp;gt; oldList = inspectionMap.get(key); oldList.add(input); } } return inspectionMap.values().stream().toList(); }}Spent time 20mReview 처음에는 1) 글자수로 grouping, 2) 글자의 합으로 grouping 하여 풀이를 시도하였다. (Example 전부 PASS) 하지만 글자수가 같으면서도 글자의 합이 같은 CASE 에서 실패했고.. discussion 살짝 보고 정렬 + map 힌트를 얻어서 풀었다." }, { "title": "LeetCode 258. Add Digits", "url": "/posts/LeetCode-258-Add-Digits/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-10-10 00:00:00 +0900", "snippet": "258. Add DigitsProblemGiven an integer num, repeatedly add all its digits until the result has only one digit, and return it.Questions before reading exampleExampleInput: num = 38Output: 2Explanation: The process is38 --&amp;gt; 3 + 8 --&amp;gt; 1111 --&amp;gt; 1 + 1 --&amp;gt; 2Since 2 has only one digit, return it.Solution 나의 풀이class Solution { public int addDigits(int num) { String numString = String.valueOf(num); while (numString.length() &amp;gt; 1) { int sum = 0; for (char c : numString.toCharArray()) { sum += c - &#39;0&#39;; } numString = String.valueOf(sum); } return Integer.parseInt(numString); }} 재귀로 푼 풀이 class Solution {public int sumDigits(int n) { if (n == 0) return 0; return (n % 10) + sumDigits(n / 10);}} Spent time 5mReview HappyNumber 와 같은 방법으로 풀었다. 재귀로도 문제를 깔끔하게 풀 수 있는데.. 이 방법에 더 익숙해지고 싶다." }, { "title": "LeetCode 202. Happy Number", "url": "/posts/LeetCode-202-Happy-Number/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-10-08 18:30:00 +0900", "snippet": "202. Happy NumberProblemWrite an algorithm to determine if a number n is happy.A happy number is a number defined by the following process:Starting with any positive integer, replace the number by the sum of the squares of its digits.Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.Those numbers for which this process ends in 1 are happy.Return true if n is a happy number, and false if not.Questions before reading example// is it possible to pass n zero?// what is a max number of n?// can i loop infinitely?ExampleInput: n = 19Output: trueExplanation:12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1Input: n = 2Output: falseSolution 나의 풀이class Solution { public boolean isHappy(int n) { Set&amp;lt;String&amp;gt; seen = new HashSet&amp;lt;&amp;gt;(); String numberString = String.valueOf(n); seen.add(numberString); while (true) { int sum = 0; for (char c: numberString.toCharArray()) { sum += (c - &#39;0&#39;) * (c - &#39;0&#39;); } numberString = String.valueOf(sum); if (seen.contains(numberString)) { break; } else { seen.add(numberString); } } return numberString.equals(&quot;1&quot;); }}Spent time 20mReview 무한 루프 탈출 조건에 대해 생각해내기 어려웠다. (단순히 length 가 2이상이면 탈출 조건으로 했었다) “7이 왜 unhappy 한 number 이지” 고민하다가, solution 을 보고 cycle 이 생긴다는 것을 알아내어 Set 을 사용하여 해결했다." }, { "title": "LeetCode 17. Letter Combinations of Phone Number", "url": "/posts/LeetCode-17-Letter-Combinations-Of-Phone-Number/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-10-08 17:30:00 +0900", "snippet": "17. Letter Combinations of Phone NumberProblemGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.(그림)Questions before reading exampleExampleInput: digits = &quot;23&quot;Output: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]Input: digits = &quot;&quot;Output: []Input: digits = &quot;2&quot;Output: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]Solution 나의 풀이class Solution { public List&amp;lt;String&amp;gt; letterCombinations(String digits) { Queue&amp;lt;String&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); for (char character : digits.toCharArray()) { if (character == &#39;2&#39;) { queue.add(&quot;abc&quot;); } else if (character == &#39;3&#39;) { queue.add(&quot;def&quot;); } else if (character == &#39;4&#39;) { queue.add(&quot;ghi&quot;); } else if (character == &#39;5&#39;) { queue.add(&quot;jkl&quot;); } else if (character == &#39;6&#39;) { queue.add(&quot;mno&quot;); } else if (character == &#39;7&#39;) { queue.add(&quot;pqrs&quot;); } else if (character == &#39;8&#39;) { queue.add(&quot;tuv&quot;); } else if (character == &#39;9&#39;) { queue.add(&quot;wxyz&quot;); } } if (queue.isEmpty()) { return List.of(); } String first = queue.poll(); List&amp;lt;String&amp;gt; results = first.chars() .mapToObj(c -&amp;gt; (char) c) .map(Object::toString) .toList(); while (!queue.isEmpty()) { String popped = queue.poll(); List&amp;lt;String&amp;gt; tempResults = new ArrayList&amp;lt;&amp;gt;(); for (String currentResult : results) { for (char c : popped.toCharArray()) { tempResults.add(currentResult + c); } } results = tempResults; } return results; }} DISCUSSION 에서 본 DFS 로 푼 풀이 public class Solution { private static final String[] KEYS = { &quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot; }; public List&amp;lt;String&amp;gt; letterCombinations(String digits) { List&amp;lt;String&amp;gt; ret = new LinkedList&amp;lt;String&amp;gt;(); combination(&quot;&quot;, digits, 0, ret); return ret; } private void combination(String prefix, String digits, int offset, List&amp;lt;String&amp;gt; ret) { if (offset &amp;gt;= digits.length()) { ret.add(prefix); return; } String letters = KEYS[(digits.charAt(offset) - &#39;0&#39;)]; for (int i = 0; i &amp;lt; letters.length(); i++) { combination(prefix + letters.charAt(i), digits, offset + 1, ret); } } } Spent timeReview 머리로는 풀이법이 떠오르지만.. 코드로 표현이 잘 되지 않아 중간에 포기할뻔도 했지만 Queue (BFS) 를 사용하니 한번에 쉽게 풀렸다. (처음에는 DFS 를 사용하여 풀려고 했다) DFS 풀이법도 친숙해져야겠다.." }, { "title": "LeetCode 118. Pascal&#39;s Triangle", "url": "/posts/LeetCode-118-Pascal-Triangle/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-09-19 00:00:00 +0900", "snippet": "118. Pascal’s TriangleProblemGiven an integer numRows, return the first numRows of Pascal&#39;s triangle.In Pascal&#39;s triangle, each number is the sum of the two numbers directly above it as shown:(그림)Questions before reading exampleExampleInput: numRows = 5Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]Input: numRows = 1Output: [[1]]Solution 나의 풀이class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generate(int numRows) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; results = new ArrayList&amp;lt;&amp;gt;(); results.add(List.of(1)); if (numRows == 1) { return results; } results.add(List.of(1, 1)); if (numRows == 2) { return results; } for (int i = 2; i &amp;lt; numRows; i++) { List&amp;lt;Integer&amp;gt; previousRow = results.get(i - 1); List&amp;lt;Integer&amp;gt; newRow = new ArrayList&amp;lt;&amp;gt;(); newRow.add(1); for (int j = 1; j &amp;lt; previousRow.size(); j++) { newRow.add(previousRow.get(j-1) + previousRow.get(j)); } newRow.add(1); results.add(newRow); } return results; }}Spent timeReview Easy 난이도여서 그런지 무식하게 푸니 풀렸다." }, { "title": "LeetCode 26. Remove Duplicates From Sorted Array", "url": "/posts/LeetCode-26-Remove-Duplicates-From-Sorted-Array/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-09-05 23:50:00 +0900", "snippet": "26. Remove Duplicates From Sorted ArrayProblemGiven an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.Return k after placing the final result in the first k slots of nums.Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.Custom Judge:The judge will test your solution with the following code:int[] nums = [...]; // Input arrayint[] expectedNums = [...]; // The expected answer with correct lengthint k = removeDuplicates(nums); // Calls your implementationassert k == expectedNums.length;for (int i = 0; i &amp;lt; k; i++) { assert nums[i] == expectedNums[i];}If all assertions pass, then your solution will be accepted.Questions before reading example// can i only use O(1) extra memory?// is it possible to receive an empty input ?// is it possible to receive an array contains negative value?ExampleExample 1:Input: nums = [1,1,2]Output: 2, nums = [1,2,_]Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.It does not matter what you leave beyond the returned k (hence they are underscores).Example 2:Input: nums = [0,0,1,1,1,2,2,3,3,4]Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.It does not matter what you leave beyond the returned k (hence they are underscores).Solution 나의 풀이class Solution { public int removeDuplicates(int[] nums) { int currentNum = -1000; int count = 0; for (int i = 0; i &amp;lt; nums.length; i++) { if (currentNum == nums[i]) { nums[i] = 99999; continue; } currentNum = nums[i]; count++; } Arrays.sort(nums); return count; }} 다른 깔끔 &amp;amp; 좋은 아이디어 풀이 public class Solution {public int removeDuplicates(int[] nums) { int i = 0; for (int n : nums) if (i == 0 || n &amp;gt; nums[i-1]) nums[i++] = n; return i;}} Spent time 10분?Review 처음에 영어 내용만 읽고 문제를 이해하기가 어려웠다. array 의 index 를 수정할 생각에.. 머리가 하앴지만,필살기?급인 Arrays.sort() 를 이용하여서 풀었다. 매직넘버가 두개나 있는 좋은 코드는 아니어서, 디스커션을 찾아보았는데, 역시나 깔끔하고 좋은 방법이.. 별거 아닌 코드처럼 보이지만, 저런 방법을 어떻게 한번에 생각해내서 풀 수 있을까.. 그저 감탄이다." }, { "title": "LeetCode 20. Valid Parentheses", "url": "/posts/LeetCode-20-ValidParentheses/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-09-05 22:30:00 +0900", "snippet": "20. Valid ParenthesesProblemGiven a string s containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.An input string is valid if:Open brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order.Every close bracket has a corresponding open bracket of the same type.Questions before reading example// * Can I get an empty value in the input?// * Can i get any other inputs except brackets?// * Can i use Stack library?ExampleExample 1:Input: s = &quot;()&quot;Output: trueExample 2:Input: s = &quot;()[]{}&quot;Output: trueExample 3:Input: s = &quot;(]&quot;Output: falseSolution 나의 풀이class Solution { public boolean isValid(String s) { if (s.length() &amp;lt; 1) { return false; } Deque&amp;lt;Character&amp;gt; stack = new ArrayDeque&amp;lt;&amp;gt;(); for (char character : s.toCharArray()) { if (character == &#39;(&#39; || character == &#39;{&#39; || character == &#39;[&#39;) { stack.push(character); } else if (character == &#39;)&#39;) { if (stack.isEmpty()) { return false; } char charInStack = stack.pop(); if (charInStack != &#39;(&#39;) { return false; } } else if (character == &#39;}&#39;) { if (stack.isEmpty()) { return false; } char charInStack = stack.pop(); if (charInStack != &#39;{&#39;) { return false; } } else if (character == &#39;]&#39;) { if (stack.isEmpty()) { return false; } char charInStack = stack.pop(); if (charInStack != &#39;[&#39;) { return false; } } } return stack.isEmpty(); }} 다른 깔끔 풀이 public class Solution { public boolean isValid(String s) { Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;Character&amp;gt;(); // Iterate through string until empty for(int i = 0; i&amp;lt;s.length(); i++) { // Push any open parentheses onto stack if(s.charAt(i) == &#39;(&#39; || s.charAt(i) == &#39;[&#39; || s.charAt(i) == &#39;{&#39;) stack.push(s.charAt(i)); // Check stack for corresponding closing parentheses, false if not valid else if(s.charAt(i) == &#39;)&#39; &amp;amp;&amp;amp; !stack.empty() &amp;amp;&amp;amp; stack.peek() == &#39;(&#39;) stack.pop(); else if(s.charAt(i) == &#39;]&#39; &amp;amp;&amp;amp; !stack.empty() &amp;amp;&amp;amp; stack.peek() == &#39;[&#39;) stack.pop(); else if(s.charAt(i) == &#39;}&#39; &amp;amp;&amp;amp; !stack.empty() &amp;amp;&amp;amp; stack.peek() == &#39;{&#39;) stack.pop(); else return false; } // return true if no open parentheses left in stack return stack.empty(); }} Spent timeReview 처음에 스택을 사용해서 푼다는 것만 기억이 나고.. 구체적으로 어떻게 풀어야할지 기억이 잘 나지 않았다. 대학생때부터 수없이 풀었던 문제인데.. 한번에 풀지 못하고, 코너 케이스 (Ex. 입력이 “]” 인 경우) 를 해결해나가며 3번만에 풀었다." }, { "title": "LeetCode 14. Longest Common Prefix", "url": "/posts/LeetCode-14-LongestCommonPrefix/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-08-15 23:30:00 +0900", "snippet": "14. Longest Common PrefixProblemWrite a function to find the longest common prefix string amongst an array of strings.If there is no common prefix, return an empty string &quot;&quot;.Questions before reading example// Q) Only 6 exception cases doing subtraction? // =&amp;gt; YesExampleExample 1:Input: strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot;Example 2:Input: strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings.Solution 나의 풀이class Solution { public String longestCommonPrefix(String[] strs) { String result = &quot;&quot;; String standard = strs[0]; for (int i = 0; i &amp;lt; standard.length(); i++) { char standardChar = standard.charAt(i); boolean isSame = false; for (int j = 0; j &amp;lt; strs.length; j++) { if (strs[j].length() &amp;lt;= i) { break; } if (strs[j].charAt(i) == standardChar) { isSame = true; } else { isSame = false; break; } if (j == strs.length -1) { result += standardChar; } } if (!isSame) { break; } } return result; }}Spent timeReview 보자마자 정말 쉬운 문제라고 생각했는데.. 생각보다 문제해결 방법을 코드로 구현하는데에 시간이 걸렸다. 자신이 있는 나머지 문제 풀기전에 예외 케이스에 대한 질문거리를 남기지 않았는데, 이게 독이 되었다 예외 케이스에 대한 코드 (ex. input 이 1개인 경우, 첫번째 input 의 길이가 짧은 경우 ..) 에 대해 고려를 하지 않아서 if 문이 덕지덕지 붙었다. " }, { "title": "LeetCode 13. Roman To Integer", "url": "/posts/LeetCode-13-Roman-To-Integer/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-08-14 23:00:00 +0900", "snippet": "13. Roman To IntegerProblemRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M.Symbol ValueI 1V 5X 10L 50C 100D 500M 1000For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer.Questions before reading example// Q) Only 6 exception cases doing subtraction? // =&amp;gt; YesExampleExample 1:Input: s = &quot;III&quot;Output: 3Explanation: III = 3.Example 2:Input: s = &quot;LVIII&quot;Output: 58Explanation: L = 50, V= 5, III = 3.Example 3:Input: s = &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.Solution 나의 풀이class Solution { public int romanToInt(String s) { int result = 0; for (int i = 0; i &amp;lt; s.length(); i++) { if (s.charAt(i) == &#39;I&#39;) { if (i &amp;lt; s.length() - 1) { if (s.charAt(i + 1) == &#39;V&#39;) { result += 4; i++; continue; } else if (s.charAt(i + 1) == &#39;X&#39;) { result += 9; i++; continue; } } result += 1; } else if (s.charAt(i) == &#39;V&#39;) { result += 5; } else if (s.charAt(i) == &#39;X&#39;) { if (i &amp;lt; s.length() - 1) { if (s.charAt(i + 1) == &#39;L&#39;) { result += 40; i++; continue; } else if (s.charAt(i + 1) == &#39;C&#39;) { result += 90; i++; continue; } } result += 10; } else if (s.charAt(i) == &#39;L&#39;) { result += 50; } else if (s.charAt(i) == &#39;C&#39;) { if (i &amp;lt; s.length() - 1) { if (s.charAt(i + 1) == &#39;D&#39;) { result += 400; i++; continue; } else if (s.charAt(i + 1) == &#39;M&#39;) { result += 900; i++; continue; } } result += 100; } else if (s.charAt(i) == &#39;D&#39;) { result += 500; } else if (s.charAt(i) == &#39;M&#39;) { result += 1000; } } return result; }} 깔끔한 다른 풀이 (python) class Solution: def romanToInt(self, s: str) -&amp;gt; int: translations = { &quot;I&quot;: 1, &quot;V&quot;: 5, &quot;X&quot;: 10, &quot;L&quot;: 50, &quot;C&quot;: 100, &quot;D&quot;: 500, &quot;M&quot;: 1000 } number = 0 s = s.replace(&quot;IV&quot;, &quot;IIII&quot;).replace(&quot;IX&quot;, &quot;VIIII&quot;) s = s.replace(&quot;XL&quot;, &quot;XXXX&quot;).replace(&quot;XC&quot;, &quot;LXXXX&quot;) s = s.replace(&quot;CD&quot;, &quot;CCCC&quot;).replace(&quot;CM&quot;, &quot;DCCCC&quot;) for char in s: number += translations[char] return number Spent timeReview 오랜만에 몸풀기 문제로 가장 쉬워보이는 문제를 골랐다. 무식하게(?) 생각나는대로 풀었다. (물론 한번에 풀리진 않고, 중간에 실수는 있었다) if - else 문이 많은게 극혐이긴 하다.. 미리 6가지 케이스를 replace 해서 if 문을 줄이는 방법이 아주 깔끔하고 훌륭하다." }, { "title": "LeetCode 937. Reorder Data in Log Files", "url": "/posts/LeetCode-937-Reorder-Data-In-Log-Files/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-05-29 10:30:00 +0900", "snippet": "397. Reorder Data in Log FilesProblemYou are given an array of logs. Each log is a space-delimited string of words, where the first word is the identifier.There are two types of logs:Letter-logs: All words (except the identifier) consist of lowercase English letters.Digit-logs: All words (except the identifier) consist of digits.Reorder these logs so that:The letter-logs come before all digit-logs.The letter-logs are sorted lexicographically by their contents. If their contents are the same, then sort them lexicographically by their identifiers.The digit-logs maintain their relative ordering.Return the final order of the logs.Questions before reading example// Q)// 1. identifier with empty is available?// =&amp;gt; nope// 2. all words have identifier ?// =&amp;gt; yeap// 3. what is a identifier?// =&amp;gt; the word whicch has a specific rule// 4. any other exceptional case? uppercase words, other words..// =&amp;gt; maybeExampleInput: logs = [&quot;dig1 8 1 5 1&quot;,&quot;let1 art can&quot;,&quot;dig2 3 6&quot;,&quot;let2 own kit dig&quot;,&quot;let3 art zero&quot;]Output: [&quot;let1 art can&quot;,&quot;let3 art zero&quot;,&quot;let2 own kit dig&quot;,&quot;dig1 8 1 5 1&quot;,&quot;dig2 3 6&quot;]Explanation:The letter-log contents are all different, so their ordering is &quot;art can&quot;, &quot;art zero&quot;, &quot;own kit dig&quot;.The digit-logs have a relative order of &quot;dig1 8 1 5 1&quot;, &quot;dig2 3 6&quot;.Input: logs = [&quot;a1 9 2 3 1&quot;,&quot;g1 act car&quot;,&quot;zo4 4 7&quot;,&quot;ab1 off key dog&quot;,&quot;a8 act zoo&quot;]Output: [&quot;g1 act car&quot;,&quot;a8 act zoo&quot;,&quot;ab1 off key dog&quot;,&quot;a1 9 2 3 1&quot;,&quot;zo4 4 7&quot;]Solution Discussion 을 참고한 나의 풀이class Solution { public String[] reorderLogFiles(String[] logs) { List&amp;lt;String&amp;gt; letterLogs = new ArrayList&amp;lt;&amp;gt;(); List&amp;lt;String&amp;gt; digitLogs = new ArrayList&amp;lt;&amp;gt;(); for (String log : logs) { if (isDigit(log.charAt(log.length() - 1))) { digitLogs.add(log); } else { letterLogs.add(log); } } List&amp;lt;String&amp;gt; sortedLetterLogs = letterLogs.stream() .sorted(Comparator.comparing((String log) -&amp;gt; { String identifier = log.split(&quot; &quot;)[0]; return log.substring(identifier.length()); }).thenComparing((String log) -&amp;gt; { String identifier = log.split(&quot; &quot;)[0]; return identifier; })) .collect(Collectors.toList()); sortedLetterLogs.addAll(digitLogs); return sortedLetterLogs.toArray(String[]::new); } private static boolean isDigit(Character character) { return (int) character &amp;gt;= 48 &amp;amp;&amp;amp; (int) character &amp;lt;= 57; }}Spent time 1시간 30분..?Review 문제를 제대로 읽지 못해서 한참 헤매였다. 코너 케이스를 제대로 파악하지 못하였다. 처음에는 Map 으로 풀려고 했다. (이것도 한참 걸렸다..) 그런데 Key (identifier) 가 중복이 되는 CASE 가 있어서 포기했다. Discussion 을 보니.. 이것 이외에도 문제를 잘못읽은 부분이 있었다. 크게 digits 과 letters 를 분류, (이 과정에서 처음에 input String 을 그대로 관리하면 됐는데, 이를 또 쪼개려 했다) letters sorting (이 과정에서 contents 가 같으면 identifier 를 비교해야하는것도 놓쳤다.) 두가지만 잘하면 쉽게 풀리는 문제인데.. 너무 헤맸다. 아직 많이 부족하다.." }, { "title": "LeetCode 2007. Find Original Array From Doubled Array", "url": "/posts/LeetCode-2007-FindOriginalArrayFromDoubledArray/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-03-13 21:00:00 +0900", "snippet": "2007. Find Original Array From Doubled ArrayProblemAn integer array original is transformed into a doubled array changed by appending twice the value of every element in original, and then randomly shuffling the resulting array.Given an array changed, return original if changed is a doubled array. If changed is not a doubled array, return an empty array. The elements in original may be returned in any order.Questions before reading exampleExampleInput: changed = [1,3,4,2,6,8]Output: [1,3,4]Explanation: One possible original array could be [1,3,4]:- Twice the value of 1 is 1 * 2 = 2.- Twice the value of 3 is 3 * 2 = 6.- Twice the value of 4 is 4 * 2 = 8.Other original arrays could be [4,3,1] or [3,1,4].Input: changed = [6,3,0,1]Output: []Explanation: changed is not a doubled array.Input: changed = [1]Output: []Explanation: changed is not a doubled array.Solution Discussion 을 참고한 나의 풀이class Solution { public int[] findOriginalArray(int[] changed) { if (changed.length % 2 != 0) { return new int[0]; } Arrays.sort(changed); Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); int[] results = new int[changed.length / 2]; int index = 0; for (int i = changed.length - 1; i &amp;gt;= 0; i--) { int twice = changed[i] * 2; if (map.containsKey(twice)) { if (map.get(twice) == 1) { map.remove(twice); } else { map.put(twice, map.get(twice) - 1); } results[index++] = changed[i]; } else { map.put(changed[i], map.getOrDefault(changed[i], 0) + 1); } } return index == changed.length / 2 ? results : new int[]{}; }}Spent time 40분Review 보자 마자 Map 을 잘 활용하면 되겠구나 싶어서 바로 풀이에 들어갔는데.. 역시나 실패했다. 아래 내용들이 실패의 원인이고, Discussion 을 보며 결국 풀 수 있었다. twice 한 숫자가 Doubled Array 후보가 되는 경우를 잡아내기 map 으로 처리 후 결과를 위해 연산하는게 아니라 result 배열을 선언해서 한번에 결과 도출하기 index.. 갯수가 홀수개인 경우 바로 제외 시키기. " }, { "title": "LeetCode 11. Container With Most Water", "url": "/posts/LeetCode-11-ContainerWithMostWater/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-03-13 19:30:00 +0900", "snippet": "11. Container With Most WaterProblemYou are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store.Notice that you may not slant the container.Questions before reading exampleExampleInput: height = [1,8,6,2,5,4,8,3,7]Output: 49Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.Input: height = [1,1]Output: 1Solution 나의 풀이 (1차 시도 - 실패)class Solution { public int maxArea(int[] height) { // 무식하게 풀어보았지만 실패 .. int maxArea = 0; for (int i = 1; i &amp;lt; height.length + 1; i++) { for (int j = i; j &amp;gt; 0 &amp;amp;&amp;amp; i &amp;lt; height.length; j--) { int areaWidth = j; int areaHeight = Math.min(height[i], height[i - j]); int area = areaWidth * areaHeight; if (area &amp;gt; maxArea) { maxArea = area; } } } return maxArea; }} 나의 풀이 (2차 시도 - 성공)class Solution { public int maxArea(int[] height) { // Discussion 에서 힌트를 얻은 후 int left = 0; int right = height.length - 1; int maxArea = 0; while (left &amp;lt; right) { maxArea = Math.max(maxArea, (Math.min(height[left], height[right]) * (right - left))); if (height[left] &amp;lt; height[right]) { left++; } else { right--; } } return maxArea; }}Spent time 30분Review 분명 풀어 본 익숙한 문제이다.. 과거 NHN 신입 코테 수준을 검토할때 풀어 본 문제다. 처음 접근은.. 시간복잡도를 고려하지 않고, 규칙을 찾아 for 문에 때려박는다고 생각하고 무식하게 풀어보려고 했다. ex) 1 8 일때 =&amp;gt; 1 * 1 1 8 6 일때 =&amp;gt; 1 * 2, 6 * 1 1 8 6 2 일때 =&amp;gt; 1 * 3, 2 *2, 2 * 1 예제의 답은 모두 풀었으나 시간복잡도 O(n^2) 으로 인해 timeout.. 시간 복잡도를 개선하려 고민해보았다. memoization 을 활용할 수 있는 DP 문제 인가? NO Map 활용해서 for 문을 줄일 수 있는가? NO 결국 디스커션을 보았고.. 문제 접근을 달리하여 아주 심플하게 풀 수 있었다. left 와 right 를 활용하는.. 처음부터 무지성으로 문제를 접근해서 실패했다.. 아마 계속 시도해도 전혀 생각하지 못했을 것이다. 생각해내더라도 왠지 코너케이스가 있을 것 같아 불안했을 것이다. 문제를 올바르게 파악하고 해결하려는 아이디어를 떠올리는게 정말 중요하다.." }, { "title": "LeetCode 78. Subsets", "url": "/posts/LeetCode-78-Subsets/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-02-19 16:00:00 +0900", "snippet": "78. SubsetsProblemGiven an integer array nums of unique elements, return all possible subsets (the power set).The solution set must not contain duplicate subsets. Return the solution in any order.Questions before reading example nums empty? min/max length? unique? empty subset?ExampleInput: nums = [1,2,3]Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]Input: nums = [0]Output: [[],[0]]Solution 나의 풀이 class Solution {public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets(int[] nums) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; results = new ArrayList&amp;lt;&amp;gt;(); backtracking(nums, new ArrayList&amp;lt;&amp;gt;(), results, 0); return results;}private void backtracking(int[] nums, List&amp;lt;Integer&amp;gt; candidates, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; results, int start) { results.add(new ArrayList&amp;lt;&amp;gt;(candidates)); for (int i = start; i &amp;lt; nums.length; i++) { candidates.add(nums[i]); backtracking(nums, candidates, results, i + 1); candidates.remove(candidates.size() - 1); }}} Spent timeReview 46 Permutations 에 이어 연속적으로 풀어본 백트래킹 문제 풀이법이 거의 비슷하다 주요 포인트는 results.add(new ArrayList&amp;lt;&amp;gt;(candidates));" }, { "title": "LeetCode 46. Permutations", "url": "/posts/LeetCode-46-Permutations/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-02-19 14:00:00 +0900", "snippet": "46. PermutationsProblemGiven an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.Questions before reading exampleExampleInput: nums = [1,2,3]Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]Input: nums = [0,1]Output: [[0,1],[1,0]]Input: nums = [1]Output: [[1]]Solution 나의 풀이```javaclass Solution { int[] visited; public List&amp;lt;List&amp;gt; permute(int[] nums) { visited = new int[nums.length]; List&amp;lt;List&amp;gt; results = new ArrayList&amp;lt;&amp;gt;(); dfs(nums, new ArrayList&amp;lt;&amp;gt;(), results); return results;} private void dfs(int[] nums, List candidates, List&amp;lt;List&amp;gt; results) { if (candidates.size() == nums.length) { results.add(new ArrayList&amp;lt;&amp;gt;(candidates)); return; } for (int i = 0; i &amp;lt; nums.length; i++) { if (visited[i] == 1) { continue; } visited[i] = 1;candidates.add(nums[i]);dfs(nums, candidates, results);candidates.remove(candidates.size() - 1);visited[i] = 0; } } }* 다른 풀이 (`백트래킹` + `리스트 contains`)```javapublic List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute(int[] nums) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); // Arrays.sort(nums); // not necessary backtrack(list, new ArrayList&amp;lt;&amp;gt;(), nums); return list;}private void backtrack(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list, List&amp;lt;Integer&amp;gt; tempList, int [] nums){ if(tempList.size() == nums.length){ list.add(new ArrayList&amp;lt;&amp;gt;(tempList)); } else{ for(int i = 0; i &amp;lt; nums.length; i++){ if(tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); } }}Spent timeReview 기본적인 “순열” 문제. visited 라는 아이디어는 떠올렸지만, 한번에 풀지 못하고 다른 풀이를 참고했다.. 백트래킹" }, { "title": "LeetCode 412. FizzBuzz", "url": "/posts/LeetCode-429-N-ary-Tree-Level-Order-Traversal/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-02-13 22:30:00 +0900", "snippet": "429. N-ary Tree Level Order TraversalProblemGiven an n-ary tree, return the level order traversal of its nodes&#39; values.Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).Questions before reading exampleExampleInput: root = [1,null,3,2,4,null,5,6]Output: [[1],[3,2,4],[5,6]]Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]Solutionclass Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(Node root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); if (root == null) { return result; } Queue&amp;lt;Node&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(root); while (!queue.isEmpty()) { List&amp;lt;Integer&amp;gt; nLevelValues = new ArrayList&amp;lt;&amp;gt;(); int size = queue.size(); for (int i = 0; i &amp;lt; size; i++) { nLevelValues.add(queue.peek().val); queue.addAll(queue.poll().children); } result.add(nLevelValues); } return result; }}Spent timeReview tree 가 나오면 dfs/bfs 부터 생각은 하지만 무얼 써야할지는 잘 떠오르지 않는다. 아직 dfs/bfs 문제 풀이가 낯설다.. 스스로 온전히 해내기 어렵다. 많이 풀어보는 수 밖에.." }, { "title": "LeetCode 206. ReverseLinkedList", "url": "/posts/LeetCode-206-Reverse-Linked-List/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-02-07 23:30:00 +0900", "snippet": "206. ReverseLinkedListProblemGiven the head of a singly linked list, reverse the list, and return the reversed list.Questions before reading exampleExampleInput: head = [1,2,3,4,5]Output: [5,4,3,2,1]Input: head = [1,2]Output: [2,1]Input: head = []Output: []Solution 나의 풀이 class Solution {public ListNode reverseList(ListNode head) { if (head == null) { return null; } Stack&amp;lt;ListNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); stack.push(head); while (head.next != null) { head = head.next; stack.push(head); } ListNode result = stack.pop(); ListNode tmp = result; while (!stack.isEmpty()) { tmp.next = stack.pop(); tmp = tmp.next; } tmp.next = null; return result;}} 다른 사람 풀이 (2개)public ListNode reverseList(ListNode head) { /* iterative solution */ ListNode newHead = null; while (head != null) { ListNode next = head.next; head.next = newHead; newHead = head; head = next; } return newHead;}public ListNode reverseList(ListNode head) { /* recursive solution */ return reverseListInt(head, null);}private ListNode reverseListInt(ListNode head, ListNode newHead) { if (head == null) return newHead; ListNode next = head.next; head.next = newHead; return reverseListInt(next, head);}Spent time 30분Review 문제를 보자마자 Stack 을 생각했다. 처음에는 Stack 에 ListNode 가 아니라 Integer 를 담는 실수를 했다. 도저히 뒤집을 수 있는 코드가 떠오르지 않았다. Stack 에 ListNode 를 담고, while 문 안에서 pop 하면서 뒤집을때에도 생각보다 어려웠다. Node 가 나오는 문제는 나중에 다시 보자." }, { "title": "LeetCode 412. FizzBuzz", "url": "/posts/LeetCode-412-FizzBuzz/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-02-07 22:30:00 +0900", "snippet": "412. Fizz BuzzProblemGiven an integer n, return a string array answer (1-indexed) where:answer[i] == &quot;FizzBuzz&quot; if i is divisible by 3 and 5.answer[i] == &quot;Fizz&quot; if i is divisible by 3.answer[i] == &quot;Buzz&quot; if i is divisible by 5.answer[i] == i (as a string) if none of the above conditions are true.Questions before reading example n always posivie? yesExampleInput: n = 3Output: [&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;]Input: n = 5Output: [&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;]Input: n = 15Output: [&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;7&quot;,&quot;8&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;11&quot;,&quot;Fizz&quot;,&quot;13&quot;,&quot;14&quot;,&quot;FizzBuzz&quot;]Solutionclass Solution { public List&amp;lt;String&amp;gt; fizzBuzz(int n) { List&amp;lt;String&amp;gt; results = new LinkedList&amp;lt;&amp;gt;(); for (int i = 1; i &amp;lt;= n; i++) { if (i % 3 == 0 &amp;amp;&amp;amp; i % 5 == 0) { results.add(&quot;FizzBuzz&quot;); } else if (i % 3 == 0) { results.add(&quot;Fizz&quot;); } else if (i % 5 == 0) { results.add(&quot;Buzz&quot;); } else { results.add(String.valueOf(i)); } } return results; }}Spent time 5분Review 이런 문제가 실제 면접에 나오면 소원이 없겠다.." }, { "title": "LeetCode 136. Single Number", "url": "/posts/LeetCode-136-SingleNumber/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-02-06 21:00:00 +0900", "snippet": "136. Single NumberProblemGiven a non-empty array of integers nums, every element appears twice except for one. Find that single one.You must implement a solution with a linear runtime complexity and use only constant extra space.Questions before reading example only constant extra space 인데 Map 을 사용해도 될까? 최악의 경우 O(n) 을 사용할텐데..ExampleInput: nums = [2,2,1]Output: 1Input: nums = [4,1,2,1,2]Output: 4Input: nums = [1]Output: 1Solution 나의 풀이 class Solution {public int singleNumber(int[] nums) { Map&amp;lt;Integer, Boolean&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { if (map.containsKey(nums[i])) { map.put(nums[i], false); } else { map.put(nums[i], true); } } return map.entrySet().stream() .filter(Entry::getValue) .map(Entry::getKey) .findFirst().orElseThrow();}} XOR 를 사용한 풀이 class Solution {public int singleNumber(int[] nums) { int ans = 0; for (int i = 0; i &amp;lt; nums.length; i++) { ans ^= nums[i]; } return ans;}} Spent time Review constant extra space 제약 조건 때문에 다른 아이디어가 없을지 고민을 꽤했지만 떠오르지 않아서 Map 으로 풀었다. (운이 좋게 PASS 한 것 같다) 다른 문제 풀이를 보니 XOR 를 이용해서 비트 연산으로 푸는거였다. XOR 는 같으면 0 다르면 1을 반환한다. " }, { "title": "LeetCode 344. Reverse String", "url": "/posts/LeetCode-344-ReverseString/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-02-06 20:30:00 +0900", "snippet": "344. Reverse StringProblemWrite a function that reverses a string. The input string is given as an array of characters s.You must do this by modifying the input array in-place with O(1) extra memory.Questions before reading example ”s” can be empty? nope ”s” max length? 10^5 ”s” only english? yesExampleInput: s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]Input: s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]Solutionclass Solution { public void reverseString(char[] s) { for (int i = 0; i &amp;lt; s.length / 2; i++) { char tmp = s[i]; s[i] = s[s.length - 1 - i]; s[s.length - 1 - i] = tmp; } }}Spent time 13분Review 생각나는 그대로 풀었는데 다행히 잘 풀렸다. index 를 다루는건 늘 조심스럽다." }, { "title": "LeetCode 104. Maximum Depth Of Binary Tree", "url": "/posts/LeetCode-104-Maximum-Depth-Of-BinaryTree/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-02-06 20:00:00 +0900", "snippet": "104. Maximum Depth Of Binary TreeProblemGiven the root of a binary tree, return its maximum depth.A binary tree&#39;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.Questions before reading example DFS vs BFS DFS 가 더 구현이 쉽기 때문에 DFS ExampleInput: root = [3,9,20,null,null,15,7]Output: 3Input: root = [1,null,2]Output: 2Solution class Solution { public int maxDepth(TreeNode root) { return dfs(root, 0); } private int dfs(TreeNode node, int currentDepth) { if (node == null) { return currentDepth; } return Math.max(dfs(node.left, currentDepth +1), dfs(node.right, currentDepth + 1)); }}Spent timeReview DFS 기본 문제인데.. 문제해결에 시간이 생각보다 걸렸다." }, { "title": "LeetCode 7. Reverse Integer", "url": "/posts/LeetCode-7-Reverse-Integer/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-02-03 21:00:00 +0900", "snippet": "7. Reverse IntegerProblemGiven a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.Assume the environment does not allow you to store 64-bit integers (signed or unsigned).Questions before reading example (memo) negative case (memo) ends with zero caseExampleInput: x = 123Output: 321Input: x = -123Output: -321Input: x = 120Output: 21Solution Character 와 Stack 을 사용한 나의 풀이 public int reverse(int x) { String s = String.valueOf(x); Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); boolean isPositive = true; for (int i = 0; i &amp;lt; s.length(); i++) { if (s.charAt(i) == &#39;-&#39;) { isPositive = false; continue; } stack.push(s.charAt(i)); } StringBuilder resultStringBuilder = new StringBuilder(); if (!isPositive) { resultStringBuilder.append(&quot;-&quot;); } while (!stack.empty()) { resultStringBuilder.append(stack.pop()); } long result = Long.parseLong(resultStringBuilder.toString()); if (result &amp;gt; Integer.MAX_VALUE || result &amp;lt; Integer.MIN_VALUE) { return 0; } return (int) result; } *(곱셈)과 %(Arithmetic Operators) 를 사용한 long -&amp;gt; int 아이디어 public int reverse(int x) { long num = 0; while (x != 0) { num = num * 10 + x % 10; x = x / 10; } if (num != (int) num) { return 0; } return (int) num; }}Spent time 7분Review Stack 을 써야겠다라는 아이디어를 얻고 무식하게 코딩했다. 다른 풀이를 보니 깔끔하고 우아한 방법은 아니다. %(Arithmetic Operators) 방법과 내 방법 모두 O(n) 이지만, 엄밀히 내 아이디어는 O(2n) 이고, 공간 복잡도가 더 높다." }, { "title": "LeetCode 1. Two Sum", "url": "/posts/LeetCode-1-Two-Sum/", "categories": "leetcode, algorithm", "tags": "algorithm", "date": "2022-02-02 22:00:00 +0900", "snippet": "1. Two SumProblemGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.You may assume that each input would have exactly one solution, and you may not use the same element twice.You can return the answer in any order.Questions before reading example “nums” 가 비어있을 수도 있는가? “nums” 의 최대 길이는? “nums” 의 element 와 target 은 항상 int 타입인가? “nums” 의 element 와 target 은 항상 양수인가? 시간복잡도가 n^2 이어도 괜찮은가?ExampleInput: nums = [2,7,11,15], target = 9Output: [0,1]Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].Solution O(n^2) public int[] twoSum(int[] nums, int target) { for (int i = 0; i &amp;lt; nums.length; i++) { for (int j = i + 1; j &amp;lt; nums.length; j++) { if (nums[i] + nums[j] == target) { return new int[]{i, j}; } } } return null; } O(n) public static int[] twoSum(int[] nums, int target) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; nums.length; i++) { int remainder = target - nums[i]; if (map.containsKey(remainder)) { return new int[]{map.get(remainder), i}; } map.put(nums[i], i); } throw new IllegalArgumentException(); }Spent time 9분Review 정말 오랜만에 풀어보았다. O(n) 풀이법은 스스로 생각하지 못해 검색을 통해 해결했다. 매일 꾸준히 연습해야지." }, { "title": "뜨거운 감자 함수형 프로그래밍", "url": "/posts/functional-programming/", "categories": "web, java, language", "tags": "java", "date": "2017-01-09 22:00:00 +0900", "snippet": "요즘 프로그래머들 사이에서 가장 뜨거운 이슈 하나를 꼽자면, 난 함수형 프로그래밍(Functional Programming)을 꼽을 것이다. 특히 요새 들어 함수형 프로그래밍 열풍이라는 것을 많이 느낀다. Java, C++, C#, JavaScript 등 사용자 층이 두텁고 각각의 철학이 있는 언어에서 함수형 패러다임을 앞다투어 차용하고 있는 현상은 물론이고, 미국에서는 스칼라가 많이 쓰인다 느니, 해외 취업을 위해선 스칼라를 공부해야 된다는 이야기부터, 회사 동료들 책상 위에 스칼라(Scala)나 하스켈(Haskell) 등의 함수형 언어 책이 놓여있는 것이 종종 보이는 것까지. 확실히 함수형 프로그래밍이 프로그래밍 패러다임에 ‘대세’를 이끌고 있다. 더군다나 얼마 전에는 사내 교육으로 임백준 님의 Reactive Programming과 Kevin Lee님의 Functional Programming 주제의 세미나를 들을 기회도 있었다. 이를 계기로 함수형 프로그래밍에 대해 더욱 많은 흥미가 생겼는데, 도대체 그 대세 함수형 프로그래밍이 무엇인지 정리해보려고 한다.함수형 프로그래밍은 순수 함수를 이용한다함수형 프로그래밍이란 무엇일까? 위키피디아에서는 ‘자료 처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임의 하나’라고 정의하고 있다. 쉽게 이해되지는 않는 말이었는데, 얼마 전 세미나에서 Kevin님께서는 ‘동일한 입력에, 동일한 결과를 얻는 것’이라고 간단한 말로 설명해주셨다. 즉, 함수형 프로그래밍은 외부 영향을 받는 입력 및 출력을 최대한 제거한 함수(순수 함수)를 이용한 프로그래밍을 말한다. 위키피디아에 있는 예로 ‘순수 함수’에 대해 부가적인 설명을 하자면, f가 순수 함수라고 할 때, 아래 코드에서 sampleA 와 sampleB의 결과는 항상 같다.int sampleA(int x) { return f(x) * f(x);}int sampleB(int x) { int a = f(x); return a * a;}그러나 f가 순수하지 않은 함수의 경우, 결과가 같지 않을 수가 있다. 아래 코드의 sampleC 함수와 sampleD 함수가 그 예이다. (함수 random은 임의의 값을 반환하는 함수라고 하자)int sampleC(int x) { return random() * random();}int sampleD(int x) { int a = random(); return a * a;}마찬가지로, C언어에서 단순히 글자를 출력하는 함수 printf 역시, 순수 함수가 아니다. C의 함수 printf는 정상적으로 출력이 되었는지 여부에 따라 0과 1을 반환하기 때문이다. 함수형 프로그래밍에 대해 다시 한번 정의하면, 함수형 프로그래밍은 부작용(side-effect)없이 외부의 영향을 받지 않는 안전한(thread-safe) 함수를 사용하는 프로그래밍이다.그럼 반대로 ‘부작용이 있는’ 함수는 무슨 문제가 있는 것일까? 함수형 프로그래밍 개발자로 유명한 Kris Jenkins가 쓴 블로그 “What is Functional Programming”에서는 부작용을 ‘복잡성 빙산’ 이라고 표현한다. 아래 설명에서는 블로그에서 든 예시와 내용을 빌리겠다. (정확히 말하면 이를 번역한 한주영 님이 쓴 블로그 ‘함수형 프로그래밍이란 무엇인가?’ 의 내용을 빌리겠다)public boolean processMessage(Channel channel) {...}위의 코드를 보고 위 함수의 기능을 알 수 있다고 생각하지만, 그 함수의 표면 아래에 숨겨진 것은 무엇이든 될 수 있기 때문에, 그 구현을 보지 않고 기능을 알 수 없다. 즉, 구현을 보지 않고서는 정말 어떤 것들이 연관되어 있을지 전혀 알 수 없기 때문에, 잠재적으로 엄청나게 큰 복잡성이 숨어 있다는 것이다 (‘캡슐화’의 개념에 대해 이야기하는 것이 아닌, ‘코드와 외부 세상과의 관계를 숨기는 것’에 대한 개념에 대해 말하는 것이다). 부작용이 있는 함수가 원래 작성한 프로그래머 예상대로 정확히 동작하면 괜찮다고 생각할 수 있겠지만, 함수가 작성되었을 때 기대했던 것과 똑같은 환경일지, 혹시 누가 어딘가를 바꾸지 않았을지, 겉으로 봐서는 전혀 연관이 없어 보이는 코드 조각을 수정했을 지 모른다. 그러나 함수형 프로그래밍은 부작용을 표면으로 드러낼 수 있다.아래의 예는 숨겨진 입력 (new Date()) 대신, 파라미터를 추가로 입력 (Date when) 받도록 바꾸어 순수 함수로 구현한 것이다.public Program getCurrentProgram(TVGuide guide, int channel) { Schedule schedule = guide.getSchedule(channel); Program current = schedule.programAt(new Date()); // 숨겨진 입력 return current;}public Program getProgramAt(TVGuide guide, int channel, Date when) { Schedule schedule = guide.getSchedule(channel); Program program = schedule.programAt(when); // 파라미터로 전환 return program;}이로써, 두개가 아닌 세개의 인자를 가져 복잡해 보일 수도 있지만, 실제로는 의존성을 정직하게 드러내 더 복잡하지 않고, 테스트도 쉽고, 추론하기도 쉬워졌다. 함수형 프로그래밍은 모든 언어에서 가능하고, 함수형 프로그래밍 언어는 부작용 없는 프로그래밍을 지원하고 장려하는 언어이다.함수형 프로그래밍은 간결하다.어떤 개체가 있을 때, 아래의 조건을 만족하면 일급 시민이라고 부른다. (1960년대 영국 컴퓨터 과학자가 만들어 낸 단어라고 한다)1. 변수나 데이터 구조 안에 담을 수 있다.2. 파라미터로 전달 할 수 있다.3. 반환 값으로 사용할 수 있다.함수형 프로그래밍은 함수 자체가 위 3개의 조건을 모두 만족한다. 즉, 함수형 프로그래밍 언어는 함수 자체가 객체 지향 언어의 클래스와 같은 일종의 타입으로 동작한다. 함수를 변수처럼 다룰 수도 있고, 다른 함수에 파라미터로 바로 넘겨줄 수도 있고, 함수를 만드는 함수(함수를 반환 값으로 가지는 함수)를 정의할 수도 있다. 이러한 특징으로 함수형 프로그래밍은 코드가 매우 간결하다.Java의 경우에도 1.8 버전부터는 method reference 기능을 제공하여 메서드(함수) 자체가 일급 시민이 되었다. 아래는 Java 1.8 버전에서 method reference 를 사용한 예이다.public static void main(String[] args) { print(String::toLowerCase, &quot;STRING TO LOWERCASE&quot;); print(String::toUpperCase, &quot;string to uppercase&quot;);}public static void print(Function&amp;lt;String, String&amp;gt; function, Strings) { System.out.println(function.apply(s));}또한, 함수형 프로그래밍은 대입문(assignment statements)없이 코딩하기 때문에 코드가 짧고 읽기 쉽다. 아래는 1부터 10까지의 숫자를 제곱한 값을 출력하는 Java코드이다.public static void main(String args[]) { for (int i=1; i&amp;lt;=25; i++) { System.out.println(i*i); }}이를 클로저(Closure) 언어로 구현하면 아래와 같다.(take 25 (squares-of (integers)))함수형 프로그래밍은 동시성(concurrency) 프로그래밍이 쉽게 가능하다.명령형 프로그래밍의 경우 동시성 프로그래밍을 설계하기도 어렵고 사용하기도 어렵다. 뮤텍스 관리를 따로 해야 하기 때문에, 가장 느린 스레드의 속도에 다른 모든 스레드가 맞춰야 하는 등 고려해야할 사항이 많기 때문이다. 반면에, 함수형 프로그래밍은 영속적 자료구조(persistent data structure)이다. 즉, 개체들이 immutable한 속성이기때문에 스레드 안정성을 보장한다. 또한 공유할 상태가 없으므로, 병목 지점이 사라지고 모든 코어, 모든 컴퓨터가 각자 낼 수 있는 가장 빠른 속도로 동작하게 된다. 이러한 장점 덕분에 함수형 프로그래밍은 비동기(Asynchronous)적으로 처리해야 하는 프로그래밍에 많이 사용된다. 비동기 프로그래밍은 동기(Synchronous) 프로그래밍과 구분이 되는데, 다음 동작 전에 필요한 값을 기다리지 않고 바로 처리하는 것을 말한다. (동기/비동기와 헷갈리는 개념으로 Blocking/Non-Blocking이 있는데, Blocking/Non-Blocking은 스레드가 개입하는 물리적 구분으로, 스레드A가 스레드B의 동작을 멈추게 하는지 마는지로 구분한다) 이러한 함수형 프로그래밍의 특징을 활용해 데이터 스트림을 비동기적 처리하는 방식이 최근에 많은 각광을 받고 있는 함수형 리액티브 프로그래밍(Functional Reactive Programming)이다. Java 1.8 버전부터는 CompletableFuture의 기능이 추가되어 Java에서도 비동기 프로그래밍을 비교적 쉽게 할 수 있다.함수형 언어가 각광받는 이유함수형 프로그래밍이 왜 대세인지 위에 나열한 특징들을 본다고 하더라도 잘 이해가 되지 않을 수 있다. 함수형 언어가 이토록 각광받고 있는 이유는 사실 프로세서 발전의 한계 요인이 가장 크다. 과거 70~80년대부터 몇년 전 까지만 해도 프로세서 하나의 성능은 굉장한 속도로 발전하였다. CPU의 성능이 18개월 마다 2배씩 향상이 된다는 법칙이 있을 정도로 CPU 성능의 발전 속도는 굉장했다. 그러나 최근에 들어서는 발전의 속도가 많이 더디어지고 있어, 프로세서의 성능보다는 프로세서를 넣을 수 있는 개수에 발전의 초점을 맞추고 있다. 즉, 프로세서의 성능보다 개수가 점차 중요해짐에 따라 동시성을 이용한 병렬/분산 프로그래밍이 중요해지고 있고, 동시성 프로그래밍을 부작용 없이 가장 잘 할 수 있는 함수형 프로그래밍이 각광을 받고 있는 것이다. 이렇기 때문에 스칼라, F#, 클로저, 하스켈과 같은 함수형 프로그래밍 언어들이 새롭게 뜨고 있고, 함수형프로그래밍이 아니던 언어Java, C++, C#, JavaScript 등에서도 함수형 프로그래밍을 조금씩 도입하고 있는 것이다.불과 1-2달 전, 함수형 프로그래밍에 대해 잘 알지 못했을 때는 객체지향 프로그래밍만이 소프트웨어 개발의 정답인 줄만 알았다. 함수형 프로그래밍이 대세를 이끌고 있다는 것을 최근에서야 많이 느껴 이렇게 공부하게 되었는데, 공부를 하면 할수록, 현재 확실히 열풍이고, 앞으로 계속해서 배워야 할 기술이라고 느꼈다. 프로그래밍 언어의 패러다임이 명령형 언어 -&amp;gt; 절차지향 언어 -&amp;gt; 객체지향 언어 순서로 변했다는 말이 있다. 이제 다음 시대는 함수형 프로그래밍이고, 지금은 그 과도기가 아닐까? 그렇다면 함수형 프로그래밍이 기존의 객체지향 프로그래밍을 완전히 대체할 수 있을까?참고 블로그 함수형 프로그래밍이란 무엇인가? (https://medium.com/@jooyunghan/함수형-프로그래밍이란-무엇인가-fab4e960d263#.8fi0a5yfs) 어떤 프로그래밍 언어들이 함수형인가? (https://medium.com/@jooyunghan/어떤-프로그래밍-언어들이-함수형인가-fec1e941c47f#.8mrcbbcil) 나무위키- 프로그래밍 언어 (https://namu.wiki/w/프로그래밍 언어#s-5.3.1) [번역] 함수형 프로그래밍(Functional Programming) 기초 (http://kwangshin.pe.kr/blog/2013/01/21/)" }, { "title": "웹서버를 두대로 늘리려면?", "url": "/posts/l4&loadbalancing/", "categories": "web", "tags": "web", "date": "2016-03-20 22:00:00 +0900", "snippet": "웹 서버를 두 대로 늘리려면? 로드 밸런싱! 고가용성!-&amp;gt; L4 스위치-&amp;gt; HAProxyL4 스위치? 다나와 검색결과.. 아주 아주 매우 비싼 장비.. IP 와 TCP/UDP 포트를 보고 적절한 서버로 패킷을 전송하는 장비 L4가 적절한 서버 고르는 방법 (로드 밸런싱 알고리즘) Least Connection 현재 세션이 가장 적은쪽으로 세션을 보내줌 * 세션을 고려하기 때문에 약간의 메모리 자원이 소비된다. 거의 5:5로 분산이 가능하지만, 경로 보장이 되지 않음. RoundRobin * 서버로 세션을 순차적으로 맺어주는 방식. * 거의 5:5 분산이 가능하지만, 경로 보장이 되지 않음. Hash * L4 자체 해싱 알고리즘을 사용하여 로드밸런싱 하는 기법. * 만일 해당 서버에 오류가 발생하거나, 서버 그룹에서 제외되거나, 추가된 경우 재할당된다. * 동일한 유저의 서비스 요청은 동일한 서버로 연결됨. * 경로가 보장되고, 메모리를 적게 사용하고 요구 절차가 간단. * 세션이 5:5로 분산되기 어렵기때문에 진정한 의미의 로드 밸런싱은 아님. Minmiss * Hash와 유사한 방식을 사용 * 만일 해당 서버에 오류가 발생하거나, 서버 그룹에서 제외되거나, 추가된 경우, 해당 서버에 할당된 사용자에에 대해서만 재할당 작업을 한다. RoundRobin &amp;amp; L7 health check RoundRobin 방식으로 Load Balancing 적용 L7 health check 적용 Layer 7 계층의 어플리케이션 응답을 체크하는 방식 1분마다 한번씩 지정 URI에 Request를 날려서 건강한 서버인지 체크 모니터 URI : GET /monitor/l7check 예상 상태코드 : 200 주기적으로 서버와 세션을 맺기 때문에 부하가 발생. But 어플리케이션 상태까지 체크가능하기 때문에 L4 health check 보다 더 서비스 안정성 보장! DSR(Direct Server Return) 모드 L4가 양방향 proxy일 경우, 모든 웹 서버가 받는 트래픽을 L4가 다 받아야 하는 문제가 생김–&amp;gt; DSR 모드! (기존) Client -&amp;gt; L4 -&amp;gt; Server -&amp;gt; L4 -&amp;gt; Client * (DSR) Client -&amp;gt; L4 -&amp;gt; Server -&amp;gt; Client * 응답이 로드밸런서를 경유하지 않고 직접 사용자에게 제공되도록 구성할 때 사용하는 방법 * 요청 패킷이 적은 케이스에 적합함 일반적인 웹 요청 * 파일 다운로드 L4 적용 기존 서비스의 System Architecture L4를 적용한 System Architecture 최종 System Architecture" }, { "title": "서블릿과 JDBC", "url": "/posts/javabook_4/", "categories": "web", "tags": "java", "date": "2016-02-10 22:00:00 +0900", "snippet": "데이터베이스를 사용하려면 필요한 것 데이터베이스에 요청을 전달하고 결과를 받을 때 사용할 도구 (JDBC) 데이터베이스에 명령을 내릴 때 사용할 언어 (SQL)Type4 JDBC 드라이버는 MySQL 통신 프로토콜에 맞추어 데이터베이스와 직접 통신하기 때문에 ODBC 드라이버를 필요로하지 않아. 그래서 실무에서 Type4 JDBC 드라이버 주로 사용JDBC API를 사용할 때는 예외가 발생할 수 있으므로 try ~ catch ~ 블록JDBC 프로그래밍을 할 때 주의할 점은 정상적으로 수행되든 오류가 발생하든 간에 반드시 자원 해제를 수행하는 것.finally 블록이 가장 적당함. ex) xxx.close();자원흘 해제할 때는 역순으로 처리.ServletGenericServlet -&amp;gt; service()HttpServlet -&amp;gt; doGeT(), doPost() …&amp;lt;a&amp;gt; 태그의 URL이 ‘/‘로 시작하면 절대경로, 그렇지 않으면 상대경로절대경로 URL : 웹 서버 루트를 기준으로 계산.상대경로 URL : 현재 경로를 기준으로 계산.HttpServlet은 상속 받을 때 service() 메소드를 그대로 구현하기보다는 클라이언트의 요처 방식에 따라 doXXX() 메소드를 오버라이딩.회원목록조회 예제와는 다르게 insert SQL문을 실행할 때는 Statement 대신 PreparedStatement를 사용해야 함.PreparedStatement는 반복적인 질의를 하거나, 입력 매개변수가 많은 경우에 유용.특히 이미지와 같은 바이너리 데이터를 저장하거나 변경할 때는 PreparedStatement만 가능.Connection conn = null;PreparedStatement stmt = null;try{ conn = DriverManager.getConnection( “jdbc:mysql://localhost/stduydb”, // JDBC URL “study”, // DBMS 사용자 아이디 “1234”); // DBMS 사용자 암호 stmt = conn.prepareStatement( “INSERT INTO MEMBERS (EMAIL, PWD&amp;lt; MNAME,CRE_DATE, MOD_DATE)&quot; + “ VALUEWS (?,?,?,NOW(),NOW())”); stmt.setString(1, request.getParameter(“email”)); stmt.setString(2, request.getParameter(“password”)); ... stmt.executeUpdate(); // 쿼리 실행} catch (Exception e) { throw new Servlet Exception(e);} finally { // 자원해제는 연결 역순 try { if (stmt != null) stmt.close();} catch (Exception e) {} try { if (conn != null) conn.close();} catch (Exception e) {}}getParameter()를 호출하면 기본적인 매개변수의 값이 ISO-Latin-1로 인식한글이 깨지는 것을 해결하려면 getParameter()를 호출하기 전에 클라이언트가 보낸 매개변수의 값이 어떤 인코딩으로 되어있는지 지정해야 해. (UTF-8)깨지는 원인은 서블릿에서 데이터를 꺼낼 때 클라이언트가 보낸 데이터를 ISO-8859-1이라 가정하고 유니코드로 변환하기 때문임.request.setCharacterEncoding(“UTF-8”);리프래시일정 기간이 지나고 나서 자동으로 서버에 요청을 보내는 방법 응답 헤더를 이용한 리프레시 response.addHeader(“Refresh”, “1;url=list”); —&amp;gt; 1초 후에 다시 서비스를 요청 HTML의 meta태그를 이용한 리프래시&amp;lt;head&amp;gt; 태그 안에 리프래시를 설정하는 &amp;lt;meta&amp;gt; 태그를 추가. &amp;lt;meta http=equiv = ‘Refresh’ content = ‘1; url=list’&amp;gt; 리다이렉트작업 결과를 출력하지 않고 즉시 다른 페이지로이동하는 것. 리다이렉트 메소드 sendRedirect() 응답코드가 200이 아닌 302 (요청한 자원이 다른 URL로 이동되었으니 Location헤더에 있는 주소로 다시 요청하라)리다이렉트할 페이지 URL이 Location헤더에 있음 웹 브라우저가 이런 응답을 받으면 즉시 Location헤더의 주소로 다시 요청함. 이런 이유로 sendRedirect()할때는 HTML 출력 코드를 작성할 필요가 없음. —&amp;gt; 작업 결과를 출력하지 않고 즉시 다른 페이지로 이동하기를 원한다면 리다이렉트 사용 —&amp;gt; 작업 결과를 잠깐이나마 출력하고 다른 페이지로 이동하기를 원한다면 리프레쉬 사용 —&amp;gt; 둘의 가장 큰 차이점은 본문을 보내냐 마느냐 서블릿 초기화 매개변수–&amp;gt; 서블릿을 생성하고 초기화할 때, 즉 init()을 호출할 때 서블릿 컨테이너가 전달하는 데이터.-—&amp;gt; 보통 데이터베이스 연결정보와 같은 정적인 데이터를 서블릿에 전달할 때 사용.web.xml이나 @WebServlet 어노테이션으로 서블릿 초기화 매개변수를 설정할 수 있음.web.xml &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;driver&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;com.mysql.jdbc.Driver&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt;@WebServlet @WebServlet( urlPatterns = {/votree/{votreeId}, initParams ={ @WebInitParam(name = “driver”, value =“com.mysql.jdbc.Driver”);, @WebInitParam(name=“url”, value=“adbc:mysql://localhost:/studydb); } )class.forName(/* 파라미터 : 클래스 */)은 인자값으로 클래스 이름을 넘기면 해당 클래스를 찾아 로딩 함.JDBC 드라이버 로딩할 때 사용.컨텍스트 초기화 매개변수서블릿 초기화 매개변수는 말 그대로 그 매개변수가 선언된 서블릿에서만 사용될 수 있음따라서 JDBC 드라이버와 데이터베이스 연결 정보에 대한 초기화 매개변수를 각 서블릿마다 별도로 설정해주어야 해.그러나 여러 서블릿이 사용하는 JDBC 드라이버와 DB연결정보가가 같다면, 각각의 서블릿마다 초기화 매개변수를 선언하는 것은 낭비. 이런 경우 컨텍스트 초기화 매개변수를 사용web.xml &amp;lt;context-param&amp;gt; &amp;lt;param-name&amp;gt;driver&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt; com.mysql.jdbc.Driver&amp;lt;/param-value&amp;gt; &amp;lt;/context-param&amp;gt; &amp;lt;context-param&amp;gt; &amp;lt;param-name&amp;gt;url&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt; jdbc:mysql://localsdfmaklsf&amp;lt;/param-value&amp;gt; &amp;lt;/context-param&amp;gt;—&amp;gt; HttpServlet으로 부터 받은 getServletcontext()를 호출해서 ServletContext 객체를 준비 해.이 객체를 통해 web.xml에 선언된 컨텍스트 초기화 매개변수값을 얻을 수 있음. ServletContext sc = this.getServletContext(); sc.getInitParameter(“url”) sc.getInitParameter(“driver”)필터서블릿 실행 전후에 어떤 작업을 하고자 할 때 사용하는 기술예를 들면, 클라이언트가 보낸 데이터의 암호를 해제한다거나,서블릿이 실행되기 전에 필요한 자원을 미리 준비한다거나, 서블릿이 실행될 때마다 로그를 남긴다거나 할 때 필터롤 틍호 처리.ex) 클라이언트가 보낸 데이터의 문자집합을 설정 압축 데이터 풀기 암호화된 데이터를 원래 데이터로 복원하기 로그 남기기 사용자 검증하기 사용권한 확인하기implements Filterinit() : 서블릿의 init()과 같은 용도. 딱 한번만 실행 됨.doFilter() : 필터와 연결된 URL에 대해 요청이 들어오면 항상 호출 됨FilterChain을 매개변수로하여 필터를 연쇄적으로 만들 수 있음.FilterChain nextFilternextFilter.doFilter()destory() : 서블릿 컨테이너는 웹 앱 종료 전에 필터들에 destroy()를 호출하여 마무리 작업을 할 수 있는 기회를 줌.web.xml &amp;lt;filter-mapping&amp;gt; &amp;lt;filter-name&amp;gt;CharacterEncodingFilter&amp;lt;/filter-name&amp;gt; &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt; &amp;lt;/filter-mapping&amp;lt;filter&amp;gt; &amp;lt;filter-name&amp;gt; CharacterEncodingFilter &amp;lt;/filter-name&amp;gt; &amp;lt;filter-class&amp;gt; spms.filters.CharacterEncodingFilter &amp;lt;/filter-class&amp;gt; &amp;lt;init-param&amp;gt; // 서블릿 초기화 매개변수와 같음. 필터를 사용할 정적인 데이터를 정의 함. 이 필터는 매개변수 값을 사용하여 요청 메시지 인코딩 설정. &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;UTF-8&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; &amp;lt;/filter&amp;gt;DB 연결정보와 같은 몇몇 설정 정보는 서버에 웹 앱을 배치한 후에도 언제든지 변경할 수 있어야 함.그런데 이런 정보를 소스코드에 넣는다면 설정정보가 바뀔때마다 매번 소스코드를 변경해야하므로 유지보수가 어려움.이러한 점을 해결하기 위해 서블릿 초기화 매개변수와 컨텍스트 초기화 매개변수를 사용해야 함.서블릿을 실행하기 전이나 후에 특별한 작업을 수행하려면 필터를 사용해야 함." }, { "title": "서블릿 프로그래밍", "url": "/posts/javabook_3/", "categories": "web", "tags": "java", "date": "2016-02-10 22:00:00 +0900", "snippet": "CGI (Common Gateway Interface)웹 서버와 프로그램 사이의 데이터를 주고 받는 규칙.웹 브라우저 &amp;lt;-&amp;gt; 웹 서버 &amp;lt;-&amp;gt; 프로그램 CGI 프로그램은 C나 C+, Java와 같은 컴파일 언어로 작성할 수 있으며, Perl, PHP, Python 등 스크립트 언어로도 작성 가능. 컴파일 방식은 기계어로 번역된 코드를 바로 실행하기 때문에 실행 속도가 빠르지만, 변경 사항이 발생할 때 마다 다시 컴파일하고 재배포해야 하는 문제가 있음.웹 서버 -&amp;gt; (실행) -&amp;gt; C/C++ 프로그램(기계어) 스크립트 방식은 소스 코드의 문법을 검증하고 해석해야 하기 때문에 실행속도가 느림. 하지만 변경 사항이 발생하면 소스코드만 수정하면 되기 때문에 편리.웹 서버 -&amp;gt; (실행) -&amp;gt; 스크립트 엔진 -&amp;gt; (해석) -&amp;gt; .php, .pl, .psp(소스)서블릿자바 CGI 프로그램은 C/C++ 처럼 컴파일 방식. 자바로 만든 CGI 프로그램을 서블릿이라고 부름.서블릿이 다른 CGI와 다른 점은, 웹 서버와 직접 데이터를 주고 받지 않으며, 전문 프로그램에 의해 관리된다는 것.‘클라이언트에게 서비스를 제공하는 작은 단위의 서버 프로그램’서블릿 컨테이너서블릿의 생성과 실행, 소멸 등 생명주기를 관리하는 프로그램.서블릿을 대신하여 CGI 규칙에 따라 웹 서버와 데이터 통신을 함. 즉 개발자가 CGI규칙 알 필요 없음.대신 서블릿컨테이너와 서블릿 사이의 규칙을 알아야 함.웹 서버 &amp;lt;-&amp;gt; 서블릿 컨테이너 &amp;lt;-&amp;gt; 서블릿WAS의 이해서블릿과 서블릿 컨테이너의 서블릿 컨테이너와 같이 웹 기술을 기반으로 동작되는 애플리케이션 서비를 WAS라 부름.Java에서 말하는 WAS는 Java EE 기술 사양을 준수하며 만든 서버를 말함. (ex. JEUS , WEB Logic, JBoss, Geronimo 등)서블릿 컨테이너 (웹 컨테이너)Java EE 기술 중에서 서블릿, JSP등 웹 관련 부분만 구현한 서버ex) 톰캣, Jetty 등서블릿의 생명주기와 관련된 메소드 : init(), service(), destroy()init() : 서블릿 컨테이너가 서블릿을 생성한 후에 초기화 작업을 수행하는 메소드. 주로 DB 연결.service() : 클라이언트가 요청할 때마다 호출되는 메소드. 실질적 서비스 작업 수행.destory() : 서블릿 컨테이너가 종료되거나 웹 앱을 멈출 때, 서블릿 비활성화 시킬 때 호출되는 메소드. 자원 해제.서블릿 인터페이스 기타 메소드 : getServletConfig(), getServletInfo()getServletConfig() : 서블릿 정보를 다루는 ServletConfig 객체를 반환.getServletInfo() :서블릿을 작성한 사람에 대한 정보, 서블릿 버전, 권리 등을 담은 문자열 반환.배치 기술서 web.xml (Depoyment Descriptor)웹 애프리케이션의 배치 정보를 담고 있는 파일. 따라서 서블릿을 만들었으면 DD 파일에 배치 정보를 등록해야 함.서블릿 구동 절차 요청 서블릿 인스턴스가 없다면 클래스로딩 인스턴스 생성 생성자 호출 init() 호출 service() 호출 응답 컨테이너 종료 destory() 호출 GenericServletservce()말고 init(), destory(), getServletConfig(), getServletInfo()는 상황에 따라 구현하지 않아도 돼.그래서 등장한게 GenericServlet.서블릿을 만들 때 GenericServlet을 상속받는다면 Servlet 인터페이스의 메소드 중에서 service()만 구현하면 됨.(service()를 제외한 나머지 메서드는 모두 구현 되어짐)" }, { "title": "Java 8 파헤치기", "url": "/posts/Java-8-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0/", "categories": "web", "tags": "java", "date": "2016-02-08 22:00:00 +0900", "snippet": "Java 8 소개들어가기전에..2014년, Java의 새로운 버전(1.8)이 공개되었다. Java의 버전 업은 Evolution (기능적인 부분의 개선)과Revoultion(언어 자체 형태의 변화)으로 나뉘는데, 이번 Java 8 버전 업은 Revolution에 속한다고 한다.Java 8에서 어떠한 기능들이 추가되었는지, 잘 정리된 여러 블로그의 글을 인용해 정리해보려고 한다.인터페이스에 찾아온 변화Java 8의 인터페이스는 default method와 static method를 포함하여 자체 구현을 가지게 되었다. default method 역시 이번 Java 8부터 추가 된 것으로, default 지시자를 이용해 기본 메소드의 정의가 가능하게되어 인터페이스를 구현하는 기존 코드의 변경없이 새 메소드의 추가가 가능해졌다. 원래 객체지향 언어에서 인터페이스는 그 시그너처와 선언이 변하지 않는다는 것을 전제로 하여 다형성(polymophism)을 정의하는 객체간의 규약이었지만, Java 8 인터페이스는 이를 확장하는 개념을 도입하였다. 이로 인해 기존 인터페이스에 비해 애매모호하다는 점과 C++과 같이 다중 상속이라는 두 가지 문제점이 예상된다. 아래는 다중 상속으로 인한 하위 클래스의 문제점을 표현한 코드이다.public interface A { default void foo() { … }}public interface B { default void foo() { … }}public class Z implements A, B { @Override public void foo() { A.super.foo(); // or B.super.foo(); }}람다 표현식 지원Java 8에 추가된 기능 중 가장 큰 변화라고 생각한다. Java 8 에서는 ‘단 하나의 메서드만 선언된 Interface’만을 람다로 표현할 수 있도록 강제하여 함수형 프로그래밍을 가능하게 한다. 여기서 정의되는 인터페이스를 ‘함수형 인터페이스’라고 정의한다. 람다식을 이용하면 동작과 데이터를 모두 동적으로 설정하는것이 가능해진다. 아래의 예제들은 모두 왼쪽이 입력값이 되고, 오른쪽이 동작에 대한 정의이다.// Concatenating strings(String s1, String s2) -&amp;gt; s1+s2;// Squaring up two integers(i1, i2) -&amp;gt; i1*i2;// Summing up the trades quantity(Trade t1, Trade t2) -&amp;gt; { t1.setQuantity(t1.getQuantity() + t2.getQuantity()); return t1;};// Expecting no arguments and invoking another method() -&amp;gt; doSomething();람다 표현은 화살표를 중심으로 두 부분으로 나뉘어진다. 왼쪽은 메소드의 인수이고 오른쪽은 이 인수로 할 일인데 예를 들어 비즈니스 로직 같은 것이다. 본문은 하나의 표현식이거나 코드 블록이고 결과값을 반환할 수도 있다.첫 번째 람다 표현 (String s1, String s2) → s1+s2에서 화살표(→)의 왼편이 메소드의 인수 리스트로 두 개의 문자열로 이루어져 있다. 메소드의 오른편을 보면 이 메소드로 구현하려는 로직을 볼 수 있다.위의 예는 두 개의 문자열이 주어졌을 때 그 둘을 합치는 것이다. 메소드에 로직을 넣으려면 화살표의 오른쪽에 오면 되는데 앞의 예에서 로직은 두 개의 인수를 더하는 것이다. 오른편에 올 수 있는 것은 문장, 표현식, 코드 블록, 다른 메소드 호출 등이다.java.util.streamJava 8은 단순히 람다 표현식을 도입할 뿐 아니라 효과적인 사용 방법을 안내하고 촉진할 수 있도록 기존 API에 람다 표현식을 대폭 적용했다. 그 대표적인 인터페이스가 Stream이다. Stream 인터페이스는 컬랙션(Collection)을 다루는 새로운 방법을 제공한다. 스트림은 컬랙션을 파이프식으로 처리하도록 하면서 고차함수로 그 구조를 추상화한다. 그래서 지연 연산이나 병렬 처리 등이 동일 인터페이스로 제공된다. 좀더 알기쉽게 설명하자면 배열이나 리스트, 맵으로 대표되는 컬랙션을 스트림으로 다룰 수 있게 되었다는 것 이다. 다음은 컬랙션에 대한 스트림화의 예이다.Stream &amp;lt;T&amp;gt; stream = collection.stream ();이것이 함수형 프로그래밍과 결합하면 다음과 같은 형태가 된다. int sumOfWeights = blocks.stream () filter (b -&amp;gt; b.getColor () == RED) . mapToInt (b -&amp;gt; b.getWeight ()) . sum ();위의 샘플코드는 stream패키지의 Javadoc에 실린 예로서, stream의 소스로서 blocks라는 Collection을 사용하고 있다. 그 스트림에 대해 filter-map-reduce를 실행하여 붉은색(RED)블록에 대한 무게(weight)의 합(sum)을 구하는 일련의 과정이 한줄의 코드에 집약되어 표현되고 있다.java.time새로운 날짜/시간 관련 API가 java.time 패키지에 추가되었다. 과거에 Java에서 날짜/시간 관련해서 Java에서 제공하는 API보다 Joda Time이라는 외부 라이브러리가 더 편리하다는 이야기를 들은 적이 있는데, 아마 이를 개선한 것 같다. 새로운 날짜/시간 클래스는 immutable이며 스레드에 대해 안전하다. 날짜 및 시간 형식으로 Instant, LocalDate, LocalDateTime, ZonedDateTime이 추가되었으며 날짜와 시간 이외의 것으로서 Duration과 Period가 추가되었다. 새로 추가된 값 형식은 Month, DayOfWeek, Year, Month YearMonth, MonthDay, OffsetTime, OffsetDateTime등이 있다. 이런한 새로운 날짜/시간 클래스는 대부분이 JDBC에서 지원됨으로서 RDB연동의 효율적인 구현이 가능하다.참고 및 인용한 블로그 한빛미디어 : 자바 8에서 새로워진 점 : 람다 More Agile : Java 8 살펴보기 Xenomity Blog 생각하고 나누고 공감하기… : Java 8 개선 사항 관련 글 모음 Clean Code that Works. : 자바 스트림 API Naver D2 : Java의 날짜와 시간 APIJava 8 의 모든 기능들은 여기에 정의되어 있다." }, { "title": "Oauth 2.0 Protocol 소개", "url": "/posts/oauth_1/", "categories": "web", "tags": "oauth", "date": "2016-01-17 22:00:00 +0900", "snippet": "Oauth 2.0 Protocol 인증 방식 (Grant types)들어가기전에.. Garden PlatformOauth 2.0 Protocol은 나에게 아주 조금은 친숙한 주제이다.과거 삼성소프트웨어 멤버십 활동 중에 멤버십 내에서 활용할 목적으로,3개월 동안 팀원들과 직접 Oauth 2.0 Provider Garden Platform을 개발한 경험이 있기 때문이다.Garden Platform 당시 Oauth 2.0 Protocol의 4가지 인증 방식(Grant Types) 중 Authorization Code Grant 방식만 서비스하였는데, 이번 포스팅을 통해 Oauth 2.0 Protocol의 4가지 인증방식에 대해 정리해보려고 한다.Oauth 2.0 Protocol Grant types Authorization Code Grant가장 많이 사용하는 Oauth 2.0 인증 방식이다. 이는 서버사이드의 코드가 필요하기 때문에 Facebook, Google 등의 Developer Page에서는 이를 서버사이드 전용 Oauth 인증 방식이라고 정의한다. 이는 Access Token을 얻기 위해 3-Legged Oauth 방식을 사용하고 그 flow는 아래와 같다. 로그인시 페이지 URL에 response_type=token 으로 넘긴다. Implicit Grant이는 보통 클라이언트 사이드 전용 Oauth 인증 방식으로 정의된다. Implicit라는 말 그대로 Access Token을 얻기 위해 Authorization Token을 이용한 보안단계를 거치지 않고 암묵적으로 권한을 주는 방식이다. Authorization Code 방식에 비해 보안이 많이 떨어지기는 하지만, 서버가 존재하지 않는 Javascript기반 브라우저 앱이나 모바일 앱에 이 방식이 이용된다고 한다. 인증을 위한 flow는 아래와 같고, 로그인시에 페이지 URL에 response_type=token 라고 넘긴다. Password Credentials Grant이는 2-legged Oauth 방식으로 Client에서 아이디와 패스워드를 이용하여 Access Token을 직접 얻어오는 방식이다. 이는 Client에게 사용자의 아이디와 패스워드가 직접적으로 노출이 되기 때문에, 써드파티 애플리케이션이 아닌, Oauth Provider가 직접적으로 제공하는 애플리케이션에서 주로 사용된다.인증을 위한 flow는 아래와 같고, 로그인시에 URL에 grant_type=password 라고 넘긴다. Client Credentials Grant이는 애플리케이션이 Confidential Client일 때, Client 자신이 resource에 대한 접근권한을 가지는 방식으로 OAuth1의 2-legged 방식과 비슷하다. 특정 Client에게 backend API의 접근을 허용하기 위한 용도로 사용할 수 있다고 한다. 인증을 위한 flow는 아래와 같고, 로그인 시에 grant_type=client_credentials 라고 넘긴다. 참고 Joinc : Oauth 2.0 소개 (http://www.joinc.co.kr/modules/moniwiki/wiki.php/man/12/oAuth2/About) RFC 6749 - The Oauth 2.0 Authorization Framework (https://tools.ietf.org/html/rfc6749)" }, { "title": "NHN Toast Rookie 3기 1주차 기술 교육 회고", "url": "/posts/1%EC%A3%BC%EC%B0%A8_%EA%B8%B0%EC%88%A0%EA%B5%90%EC%9C%A1%ED%9A%8C%EA%B3%A0/", "categories": "회사 생활", "tags": "nhn", "date": "2016-01-17 22:00:00 +0900", "snippet": "1주차 기술 교육 회고 숨 가쁜 일주일이었다.필수 구현 기능과 ‘투표 서비스’ 라는 주제만을 가지고 팀원들과 자유롭게 아이디어를 develop 시켰고,드디어 지난 금요일 기획안 초안을 완성하였다.이제 팀원들과 협업하며 기술로 구현하는 일만 남았는데, 기술 구현에 앞서 지난 일주일의 나를 회고하려 한다.내가 잘한 점 팀워크를 다지고 팀원들 간의 좋은 분위기를 위한 행동들을 서슴지 않았다. 내가 기존의 경험이 있거나, 지식이 있는 분야의 경우 전파하거나 솔선수범하려 하였다.나의 아쉬운 점 목업 UI를 만드는 점에 있어서 팀원들과 더 많은 대화를 나누지 못했다.다음주 나의 계획 다음주부터는 본격적으로 기술 개발을 시작하게 되는데, 바로 코딩을 시작하기 보다는, 리뷰 라던지 우리팀만의 프로젝트 문화를 정립하고, 또 정착시키기 위해 많은 노력을 할 것이다. 아는 것은 적극적으로 전파하고, 모르는 것은 적극적으로 물어봐야겠다. " }, { "title": "웹 프로그래밍 기초 다지기", "url": "/posts/javabook_2/", "categories": "web", "tags": "java, spring", "date": "2016-01-11 22:00:00 +0900", "snippet": "HTTP 웹 브라우저와 웹 서버 사이의 데이터 통신 규칙HTTP 모니터링 웹 브라우저와 웹 서버 사이에 주고받는 데이터를 들여다보려면 HTTP 프록시 프로그램이 필요함. 웹 브라우저 &amp;lt;-&amp;gt; HTTP 프록시 &amp;lt;-&amp;gt; 웹서버 프록시 서버는 클라이언트와 서버 사이에서 통신을 중계해 주는 컴퓨터나 프로그램. 빠른 전송을 위하여 서버의 응답 결과를 캐시에 저장 데이터를 검사하여 특정 단어 포함된 자료 송,수신 차단 (보안)HTTP Request-Line [메서드, 요청 URI, HTTP 버전] 메서드 : GET POST HEAD PUT DELETE … 요청 URI : 요청하는 자원의 식별자. 즉 HTML이 있는 가상의 경로 HTTP 버전 : 1.0, 1,1, 2.0 ..HTTP Request-Header [헤더이름/헤더 값] 헤더 일반헤더 요청헤더 또는 응답헤더 엔티티 헤더 요청헤더 중 User-Agent는 클라이언트의 정보를 서버에게 알려주어 요청자의 OS와 브라우저를 구분할 수 있음. 공백 라인과 요청 데이터(message-body) GET 요청은 공백라인으로 끝나고, POST 요청은 공백 라인 다음에 서버에 보낼 데이터(message-body)가 옴.상태 라인(Status-Line)[HTTP버 전/상태코드/상태설명] ex) HTTP1/1200_OK상태코드 200 : 요청이 성공적으로 처리되었다. 301 요청한 자원이 이동되었다. 헤더 정보에 이동 위치를 알려줄테니 다시 요청하라. 304 : 클라이언트가 임시 보관한 응답결과와 다르지 않다. 400 : 잘못된 요청이다. 404 : 요청한 자원을 못 찾았다. 500 서버 내부에서 오류가 발생하였다.응답 헤더 Content-Type 헤더는 서버가 웹브라우저에게 보내는 데이터의 형식 Content-Length는 웹 브라우저에게 보내는 데이터(message-body)의 크기(Byte)이다.공백라인과 응답 데이터(message-body) 15번 라인은 메시지 헤더와 응답 데이터를 구부하기 위한 공백 라인. 16번 라인부터 응답데이터.주요 프로토콜 FTP : 클라이언트와 서버 간에 파일을 주고받기 위해 만든 통신 규약. Telnet 프로토콜 : 인터넷이나 LAN 상에서 문자 기반으로 원격의 컴퓨터를 제어하기 위해 만든 통신 규약. 요즘은 보안때문에 SSH 많이 사용. XMPP: 인스턴트 메시지 및 접속 상태정보를 교환할 목적으로 만든 규약. ex) Google Talk SMTP : 인터넷 상에서 메일을 보내기 위한 통신 규약. POP3는 이메일을 가져오는데 사용. 이메일을 가져온 후 서버의 메일 삭제. IMAP : POP3와 달리 이메일을 가져온 뒤에 서버의 메일을 지우지 않으며, 여러 대의 장비에서 이메일을 조회하는데 적합. LDAP : 디렉터리 서비스에 등록된 자원들을 찾는 통신 규약 IRC : 실시간 채팅을 위해 만든 통신 규약.GET 특징 URL에 데이터를 포함 (데이터 조회에 적합) 바이너리 및 대용량 데이터 전송 불가 요청라인과 헤드 필드의 최대크기GET 요청 방법 웹브라우저 주소창에 URL을 입력하는 경우 링크를 클릭하는 경우 입력 폼의 method 속성값이 get인 경우GET 요청 데이터 전달 형식 서버에 보낼 데이터를 URI에 붙임. “?” 문자는 서비스 주소와 데이터를 구별하는 구분자, “&amp;amp;” 문자는 데이터들을 구별하는 구분자. “=“ 문자는 매개변수 이름과 값을 구별하는 구분자.GET 요청의 쓰임새 자료를 검색한다거나, 게시글의 상세 정보를 본다거나, 특정 상품의 정보를 조회하는 것과 같이 데이터를 조회하는 경우에 적합.GET 문제점과 개선방안 보안에 좋지 않다. 바이너리 데이터를 전송할 수 없다. (URI나 헤더 정보가 너무 크면 웹 서버에서 처리 불가)POST 특징 URL에 데이터가 포함되지 않음 –&amp;gt; 외부 노출 방지 메시지 본문에 데이터 포함 –&amp;gt; 실행 결과 공유 불가 바이너리 및 대용량 데이터 전송 가능문제점과 개선 방안 GET과 마찬가지로 데이터를 전달할 때 ‘이름=값&amp;amp;이름=값’ 형태로 전송. 이미지나 동영상과 같은 바이너리 데이터를 보낼 때 문제가 발생할 수 있음. 멀티파트 전송방식의 Content-Type 헤더를 사용하면 됨. (Content-Type : multipart/form-data; boundary=—Web … Pyz)" }, { "title": "웹 애플리케이션 이해", "url": "/posts/javabook_1/", "categories": "web", "tags": "java", "date": "2016-01-11 22:00:00 +0900", "snippet": "클라우드 웹을 기반으로 하여 서버 또는 앱, 콘텐츠 등을 제공하는 것데스크탑 앱의 문제점 배포가 번거롭 다 보안에 취약하다전통적인 클라이언트/서버 아키택처 클라이언트 : UI, 비즈니스 로직 서버 : 데이터처리(DBMS) 단점 프로그래임이 변경딜 때마다 PC에 다시 설치해야 해. 클라이언트가 DBMS로 바로 접속하기 때문에 보안 문제개선된 클라이언트/서버 아키택처 클라이언트 : UI, 입력데이터 검증 애플리케이션 서버 : 비즈니스 로직, 사용자 접근관리 서버 : 데이터처리 (DBMS)배치(Deployment)란클라이언트에서 서비스를 요청했을 때 톰캣 서버가 애플리케이션을 실행할 수 있도록 설치하는 것.기존의 C/S 환경 클라이언트 : UI 로직 서버 : 비즈니스로직웹 환경 클라이언트 : UI 로직 다운로드 후 실행 서버 : UI로직, 비즈니스 로직웹 애플리케이션의 단점 서버는 같은 화면을 반복해서 만들어야 하고, 클라이언트는 반복해서 내려받아야 해. 네트워크 자원에 대한 오버헤드 AJAX로 개선 가능 (화면은 그대로 두고 데이터만 받아오는 것) 변화에 유연한 대응이 가능한 애플리케이션 아키택처로 개선 가능 (MVC 아키택처, 빈 관리 컨테이너, 의존 객체 주입 등)" } ]
